- The actual bot is programmed in Lua, the C++ is used to abstract away most
  of the work and to execute the most time consuming parts.

    C++ side architecture:

- Instructions are the lowest level of abstraction for the bot to control
  the player. They are generated by tasks. Additionally, the execution of
  an instruction will never be interrupted (See interruption definition).
  This means that instructions should be as small as possible (I think their
  execution should take at most 5s) in order to avoid that *some* urgent
  interruptions wait to long before being triggered.

- Tasks are the highest level of abstraction to control the bot and are
  generated by the Lua side. They generate a queue of instructions that
  do the task. The execution of a task may be interrupted (See interruption
  definition). When a task is interrupted or if one instruction fails,
  the task may need to regenerate its instruction queue.
  Tasks should be independent from one another, meaning if one task fails
  and regenerate its queue, other tasks should not be affected.
  For instance, one task could be: Build a burner city with 15 iron miners,
  6 coppers, 4 stones and 12 coals.

- The bot may interrupt the current task in order to execute another more important
  task. When the interruption is done, the bot will resume the execution of paused
  task and notify it that it had been interrupted. Interruptions are raised
  by the Lua side.

    Lua side architecture:

- The C++ provides 3 global objects to the script to control the player:
    * The Bot (accessible with the "bot" global variable) which
      allows the script to queue new tasks and raise interruptions.
    * The EventManager (accessible with the "event" global variable) which is
      used to register events.
    * The MapData (accessible with the "map" global variable) which
      allows the script to get data about the map (like amount of ore patches,
      what's inside player inventory, amount of stuff buffered in chests).

    Bot member functions:
- SetResearchQueue(queue: string[])
- SetAllowResearchQueueOptimisation(allow: bool)    Sets if the bot is allowed to reorder the research queue if one science is low
- InterruptBegin(priority: int)
- InterruptEnd()
- QueueBuildBurnerCity(iron: int, copper: int, coal: int, stone: int)

    EventManager member functions:
- On(eventName: string, handler: fun(eventData)?)   Sets the handler for event eventName
- OnInterval(delay: int, handler: fun(eventData)?)  Sets an handler to be called every delay milliseconds

    Event list:
- OnTaskFinished
- OnTaskFailed
- OnIdle

    MapData member functions: